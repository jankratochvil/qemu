From 0ce1af6e7d4b1e2ffa4dedf6d415c4d86a1af490 Mon Sep 17 00:00:00 2001
From: Markus Armbruster <armbru@redhat.com>
Date: Fri, 25 Sep 2009 03:53:50 +0200
Subject: [PATCH] Make it obvious that pci_nic_init() can't fail

Before this patch, pci_nic_init() returns NULL when it can't find the
model in pci_nic_models[].  Except this can't happen, because
qemu_check_nic_model_list() just searched for model in
pci_nic_models[], and terminated the program on failure.

Repeating the search here is pointless.  Instead, change
qemu_check_nic_model_list() to return the model's array index.

Signed-off-by: Markus Armbruster <armbru@redhat.com>
Signed-off-by: Mark McLoughlin <markmc@redhat.com
Fedora-patch: qemu-do-not-exit-on-pci-hotplug-invalid-nic1.patch
---
 hw/pci.c |   25 +++++++++----------------
 net.c    |    6 +++---
 net.h    |    4 ++--
 3 files changed, 14 insertions(+), 21 deletions(-)

diff --git a/hw/pci.c b/hw/pci.c
index a575d4a..eb990f9 100644
--- a/hw/pci.c
+++ b/hw/pci.c
@@ -937,22 +937,15 @@ PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,
     DeviceState *dev;
     int i;
 
-    qemu_check_nic_model_list(nd, pci_nic_models, default_model);
-
-    for (i = 0; pci_nic_models[i]; i++) {
-        if (strcmp(nd->model, pci_nic_models[i]) == 0) {
-            pci_dev = pci_create(pci_nic_names[i], devaddr);
-            dev = &pci_dev->qdev;
-            if (nd->id)
-                dev->id = qemu_strdup(nd->id);
-            dev->nd = nd;
-            qdev_init(dev);
-            nd->private = dev;
-            return pci_dev;
-        }
-    }
-
-    return NULL;
+    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);
+    pci_dev = pci_create(pci_nic_names[i], devaddr);
+    dev = &pci_dev->qdev;
+    if (nd->id)
+        dev->id = qemu_strdup(nd->id);
+    dev->nd = nd;
+    qdev_init(dev);
+    nd->private = dev;
+    return pci_dev;
 }
 
 typedef struct {
diff --git a/net.c b/net.c
index da2f428..047e72e 100644
--- a/net.c
+++ b/net.c
@@ -2553,8 +2553,8 @@ void qemu_check_nic_model(NICInfo *nd, const char *model)
     qemu_check_nic_model_list(nd, models, model);
 }
 
-void qemu_check_nic_model_list(NICInfo *nd, const char * const *models,
-                               const char *default_model)
+int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,
+                              const char *default_model)
 {
     int i, exit_status = 0;
 
@@ -2564,7 +2564,7 @@ void qemu_check_nic_model_list(NICInfo *nd, const char * const *models,
     if (strcmp(nd->model, "?") != 0) {
         for (i = 0 ; models[i]; i++)
             if (strcmp(nd->model, models[i]) == 0)
-                return;
+                return i;
 
         fprintf(stderr, "qemu: Unsupported NIC model: %s\n", nd->model);
         exit_status = 1;
diff --git a/net.h b/net.h
index 94db0d7..9662988 100644
--- a/net.h
+++ b/net.h
@@ -80,8 +80,8 @@ void qemu_purge_queued_packets(VLANClientState *vc);
 void qemu_flush_queued_packets(VLANClientState *vc);
 void qemu_format_nic_info_str(VLANClientState *vc, uint8_t macaddr[6]);
 void qemu_check_nic_model(NICInfo *nd, const char *model);
-void qemu_check_nic_model_list(NICInfo *nd, const char * const *models,
-                               const char *default_model);
+int qemu_check_nic_model_list(NICInfo *nd, const char * const *models,
+                              const char *default_model);
 void qemu_handler_true(void *opaque);
 
 void do_info_network(Monitor *mon);
-- 
1.6.2.5

